import fs from 'fs-extra';
import path from 'path';
import { spawn } from 'child_process';
import chalk from 'chalk';
import { fileURLToPath } from 'url';
import axios from 'axios';
import semver from 'semver';
import glob from 'glob';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

/**
 * Comprehensive Vulnerability Manager
 * Handles dependency scanning, vulnerability detection, and automated fixing
 */
export class VulnerabilityManager {
  constructor(options = {}) {
    this.outputDir = options.outputDir || './reports/vulnerabilities';
    this.tempDir = path.join(this.outputDir, '.temp');
    this.vulnerabilityDb = path.join(__dirname, '../database/vulnerabilities.json');
    this.fixDb = path.join(__dirname, '../database/fixes.json');
    
    this.severityLevels = {
      'low': 1,
      'medium': 2,
      'high': 3,
      'critical': 4
    };
    
    this.packageManagers = {
      'package.json': 'npm',
      'yarn.lock': 'yarn',
      'Cargo.toml': 'cargo',
      'requirements.txt': 'pip',
      'go.mod': 'go',
      'composer.json': 'composer'
    };
  }
  
  /**
   * Scan for vulnerabilities in dependencies
   */
  async scanVulnerabilities(scanType = 'dependencies') {
    await fs.ensureDir(this.outputDir);
    await fs.ensureDir(this.tempDir);
    
    const scanResults = {
      timestamp: new Date().toISOString(),
      scanType,
      summary: {
        totalDependencies: 0,
        vulnerableDependencies: 0,
        totalVulnerabilities: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      vulnerabilities: [],
      dependencies: []
    };
    
    try {
      switch (scanType) {
        case 'dependencies':
          console.log(chalk.yellow('üì¶ Scanning dependency vulnerabilities...'));
          await this.scanDependencyVulnerabilities(scanResults);
          break;
          
        case 'containers':
          console.log(chalk.yellow('üì¶ Scanning container vulnerabilities...'));
          await this.scanContainerVulnerabilities(scanResults);
          break;
          
        case 'code':
          console.log(chalk.yellow('üìù Scanning code vulnerabilities...'));
          await this.scanCodeVulnerabilities(scanResults);
          break;
          
        case 'all':
          console.log(chalk.yellow('üîç Running comprehensive vulnerability scan...'));
          await this.scanDependencyVulnerabilities(scanResults);
          await this.scanContainerVulnerabilities(scanResults);
          await this.scanCodeVulnerabilities(scanResults);
          break;
          
        default:
          throw new Error(`Unknown scan type: ${scanType}`);
      }
      
      // Calculate summary
      scanResults.summary = this.calculateVulnerabilitySummary(scanResults.vulnerabilities);
      
      // Save results
      const outputFile = path.join(this.outputDir, `vulnerability-scan-${Date.now()}.json`);
      await fs.writeJson(outputFile, scanResults, { spaces: 2 });
      
      console.log(chalk.green(`üíæ Vulnerability scan results saved to ${outputFile}`));
      
      return scanResults;
      
    } catch (error) {
      throw new Error(`Vulnerability scan failed: ${error.message}`);
    } finally {
      await fs.remove(this.tempDir);
    }
  }
  
  /**
   * Scan dependency vulnerabilities
   */
  async scanDependencyVulnerabilities(scanResults) {
    const packageFiles = await this.findPackageFiles();
    
    for (const packageFile of packageFiles) {
      const packageManager = this.packageManagers[path.basename(packageFile)];
      
      if (!packageManager) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Unknown package file: ${packageFile}`));
        continue;
      }
      
      console.log(chalk.blue(`üìÑ Scanning ${packageFile} with ${packageManager}...`));
      
      // Try different vulnerability scanning methods
      const vulnerabilities = await this.scanWithMultipleTools(packageFile, packageManager);
      
      scanResults.vulnerabilities.push(...vulnerabilities);
      
      // Get dependency list
      const dependencies = await this.getDependencyList(packageFile, packageManager);
      scanResults.dependencies.push(...dependencies);
    }
    
    scanResults.summary.totalDependencies = scanResults.dependencies.length;
    scanResults.summary.vulnerableDependencies = new Set(
      scanResults.vulnerabilities.map(v => v.package)
    ).size;
  }
  
  /**
   * Scan with multiple vulnerability scanning tools
   */
  async scanWithMultipleTools(packageFile, packageManager) {
    const vulnerabilities = [];
    
    // Try npm audit
    if (packageManager === 'npm' || packageManager === 'yarn') {
      try {
        const npmVulns = await this.runNpmAudit(packageFile);
        vulnerabilities.push(...npmVulns);
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  npm audit failed: ${error.message}`));
      }
    }
    
    // Try Snyk (if available)
    try {
      const snykAvailable = await this.checkToolAvailability('snyk');
      if (snykAvailable) {
        const snykVulns = await this.runSnykScan(packageFile);
        vulnerabilities.push(...snykVulns);
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Snyk scan failed: ${error.message}`));
    }
    
    // Try safety for Python
    if (packageManager === 'pip') {
      try {
        const safetyVulns = await this.runSafetyScan(packageFile);
        vulnerabilities.push(...safetyVulns);
      } catch (error) {
        console.warn(chalk.yellow(`‚ö†Ô∏è  Safety scan failed: ${error.message}`));
      }
    }
    
    // Fallback to vulnerability database lookup
    if (vulnerabilities.length === 0) {
      const dbVulns = await this.scanWithVulnerabilityDatabase(packageFile, packageManager);
      vulnerabilities.push(...dbVulns);
    }
    
    return this.deduplicateVulnerabilities(vulnerabilities);
  }
  
  /**
   * Run npm audit
   */
  async runNpmAudit(packageFile) {
    return new Promise((resolve) => {
      const workingDir = path.dirname(packageFile);
      const auditProcess = spawn('npm', ['audit', '--json'], {
        cwd: workingDir,
        stdio: 'pipe'
      });
      
      let stdout = '';
      let stderr = '';
      
      auditProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      auditProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      auditProcess.on('close', (code) => {
        try {
          if (stdout) {
            const auditResult = JSON.parse(stdout);
            const vulnerabilities = this.parseNpmAuditResults(auditResult);
            resolve(vulnerabilities);
          } else {
            resolve([]);
          }
        } catch (error) {
          resolve([]);
        }
      });
      
      auditProcess.on('error', () => {
        resolve([]);
      });
    });
  }
  
  /**
   * Run Snyk scan
   */
  async runSnykScan(packageFile) {
    return new Promise((resolve) => {
      const workingDir = path.dirname(packageFile);
      const snykProcess = spawn('snyk', ['test', '--json'], {
        cwd: workingDir,
        stdio: 'pipe'
      });
      
      let stdout = '';
      
      snykProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      snykProcess.on('close', (code) => {
        try {
          if (stdout) {
            const snykResult = JSON.parse(stdout);
            const vulnerabilities = this.parseSnykResults(snykResult);
            resolve(vulnerabilities);
          } else {
            resolve([]);
          }
        } catch (error) {
          resolve([]);
        }
      });
      
      snykProcess.on('error', () => {
        resolve([]);
      });
    });
  }
  
  /**
   * Run Safety scan for Python
   */
  async runSafetyScan(packageFile) {
    return new Promise((resolve) => {
      const safetyProcess = spawn('safety', ['check', '--json', '-r', packageFile], {
        stdio: 'pipe'
      });
      
      let stdout = '';
      
      safetyProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      safetyProcess.on('close', (code) => {
        try {
          if (stdout) {
            const safetyResult = JSON.parse(stdout);
            const vulnerabilities = this.parseSafetyResults(safetyResult);
            resolve(vulnerabilities);
          } else {
            resolve([]);
          }
        } catch (error) {
          resolve([]);
        }
      });
      
      safetyProcess.on('error', () => {
        resolve([]);
      });
    });
  }
  
  /**
   * Scan with local vulnerability database
   */
  async scanWithVulnerabilityDatabase(packageFile, packageManager) {
    const vulnerabilities = [];
    const dependencies = await this.getDependencyList(packageFile, packageManager);
    
    // Load vulnerability database
    let vulnDb = {};
    try {
      if (await fs.pathExists(this.vulnerabilityDb)) {
        vulnDb = await fs.readJson(this.vulnerabilityDb);
      } else {
        vulnDb = await this.createVulnerabilityDatabase();
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Failed to load vulnerability database: ${error.message}`));
      return vulnerabilities;
    }
    
    // Check each dependency against database
    for (const dep of dependencies) {
      const packageVulns = vulnDb[dep.name] || [];
      
      for (const vuln of packageVulns) {
        if (semver.satisfies(dep.version, vuln.affectedVersions)) {
          vulnerabilities.push({
            id: vuln.id,
            package: dep.name,
            currentVersion: dep.version,
            vulnerableVersions: vuln.affectedVersions,
            fixedVersion: vuln.fixedVersion,
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            references: vuln.references,
            publishedDate: vuln.publishedDate,
            source: 'vulnerability-database'
          });
        }
      }
    }
    
    return vulnerabilities;
  }
  
  /**
   * Create local vulnerability database
   */
  async createVulnerabilityDatabase() {
    const vulnDb = {
      // Common JavaScript vulnerabilities
      'lodash': [
        {
          id: 'CVE-2020-8203',
          title: 'Prototype Pollution',
          severity: 'high',
          affectedVersions: '<4.17.19',
          fixedVersion: '4.17.19',
          description: 'Prototype pollution vulnerability in lodash',
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-8203'],
          publishedDate: '2020-07-15'
        }
      ],
      'minimist': [
        {
          id: 'CVE-2020-7598',
          title: 'Prototype Pollution',
          severity: 'high',
          affectedVersions: '<1.2.2',
          fixedVersion: '1.2.2',
          description: 'Prototype pollution vulnerability in minimist',
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2020-7598'],
          publishedDate: '2020-03-11'
        }
      ],
      'express': [
        {
          id: 'CVE-2022-24999',
          title: 'Open Redirect',
          severity: 'medium',
          affectedVersions: '<4.17.3',
          fixedVersion: '4.17.3',
          description: 'Open redirect vulnerability in express',
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2022-24999'],
          publishedDate: '2022-02-09'
        }
      ],
      // Python vulnerabilities
      'django': [
        {
          id: 'CVE-2023-24580',
          title: 'Potential DoS via file uploads',
          severity: 'medium',
          affectedVersions: '<4.1.7',
          fixedVersion: '4.1.7',
          description: 'DoS vulnerability in Django file upload handling',
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2023-24580'],
          publishedDate: '2023-02-14'
        }
      ],
      'requests': [
        {
          id: 'CVE-2023-32681',
          title: 'Unintended leak of Proxy-Authorization header',
          severity: 'medium',
          affectedVersions: '<2.31.0',
          fixedVersion: '2.31.0',
          description: 'Proxy authorization header leak in requests',
          references: ['https://nvd.nist.gov/vuln/detail/CVE-2023-32681'],
          publishedDate: '2023-05-26'
        }
      ]
    };
    
    await fs.ensureDir(path.dirname(this.vulnerabilityDb));
    await fs.writeJson(this.vulnerabilityDb, vulnDb, { spaces: 2 });
    
    return vulnDb;
  }
  
  /**
   * Auto-fix vulnerabilities
   */
  async autoFixVulnerabilities(options = {}) {
    const { dryRun = false } = options;
    
    const fixResults = {
      timestamp: new Date().toISOString(),
      dryRun,
      fixed: 0,
      skipped: 0,
      failed: 0,
      fixes: []
    };
    
    try {
      // First, scan for vulnerabilities
      const scanResults = await this.scanVulnerabilities('dependencies');
      
      if (scanResults.vulnerabilities.length === 0) {
        console.log(chalk.green('‚úÖ No vulnerabilities found to fix'));
        return fixResults;
      }
      
      console.log(chalk.blue(`üîß Found ${scanResults.vulnerabilities.length} vulnerabilities to fix`));
      
      // Group vulnerabilities by package file
      const vulnsByFile = this.groupVulnerabilitiesByFile(scanResults.vulnerabilities);
      
      for (const [packageFile, vulnerabilities] of Object.entries(vulnsByFile)) {
        const packageManager = this.packageManagers[path.basename(packageFile)];
        
        console.log(chalk.blue(`üìÑ Processing ${packageFile}...`));
        
        for (const vuln of vulnerabilities) {
          try {
            const fixApplied = await this.applyVulnerabilityFix(
              vuln,
              packageFile,
              packageManager,
              dryRun
            );
            
            if (fixApplied) {
              fixResults.fixed++;
              fixResults.fixes.push({
                package: vuln.package,
                vulnerability: vuln.id,
                fromVersion: vuln.currentVersion,
                toVersion: vuln.fixedVersion,
                status: 'fixed'
              });
              
              console.log(chalk.green(`  ‚úÖ Fixed ${vuln.package}: ${vuln.currentVersion} ‚Üí ${vuln.fixedVersion}`));
            } else {
              fixResults.skipped++;
              fixResults.fixes.push({
                package: vuln.package,
                vulnerability: vuln.id,
                status: 'skipped',
                reason: 'No automatic fix available'
              });
              
              console.log(chalk.yellow(`  ‚è≠Ô∏è  Skipped ${vuln.package}: No automatic fix available`));
            }
            
          } catch (error) {
            fixResults.failed++;
            fixResults.fixes.push({
              package: vuln.package,
              vulnerability: vuln.id,
              status: 'failed',
              error: error.message
            });
            
            console.log(chalk.red(`  ‚ùå Failed to fix ${vuln.package}: ${error.message}`));
          }
        }
      }
      
      // Save fix results
      const outputFile = path.join(this.outputDir, `vulnerability-fixes-${Date.now()}.json`);
      await fs.writeJson(outputFile, fixResults, { spaces: 2 });
      
      return fixResults;
      
    } catch (error) {
      throw new Error(`Auto-fix failed: ${error.message}`);
    }
  }
  
  /**
   * Apply vulnerability fix
   */
  async applyVulnerabilityFix(vulnerability, packageFile, packageManager, dryRun) {
    if (!vulnerability.fixedVersion) {
      return false;
    }
    
    const workingDir = path.dirname(packageFile);
    
    if (dryRun) {
      console.log(chalk.blue(`[DRY RUN] Would update ${vulnerability.package} to ${vulnerability.fixedVersion}`));
      return true;
    }
    
    switch (packageManager) {
      case 'npm':
        return this.updateNpmPackage(vulnerability.package, vulnerability.fixedVersion, workingDir);
        
      case 'yarn':
        return this.updateYarnPackage(vulnerability.package, vulnerability.fixedVersion, workingDir);
        
      case 'pip':
        return this.updatePipPackage(vulnerability.package, vulnerability.fixedVersion, workingDir);
        
      default:
        console.warn(chalk.yellow(`‚ö†Ô∏è  Automatic fixing not supported for ${packageManager}`));
        return false;
    }
  }
  
  /**
   * Update npm package
   */
  async updateNpmPackage(packageName, version, workingDir) {
    return new Promise((resolve) => {
      const updateProcess = spawn('npm', ['install', `${packageName}@${version}`], {
        cwd: workingDir,
        stdio: 'pipe'
      });
      
      updateProcess.on('close', (code) => {
        resolve(code === 0);
      });
      
      updateProcess.on('error', () => {
        resolve(false);
      });
    });
  }
  
  /**
   * Update yarn package
   */
  async updateYarnPackage(packageName, version, workingDir) {
    return new Promise((resolve) => {
      const updateProcess = spawn('yarn', ['add', `${packageName}@${version}`], {
        cwd: workingDir,
        stdio: 'pipe'
      });
      
      updateProcess.on('close', (code) => {
        resolve(code === 0);
      });
      
      updateProcess.on('error', () => {
        resolve(false);
      });
    });
  }
  
  /**
   * Update pip package
   */
  async updatePipPackage(packageName, version, workingDir) {
    return new Promise((resolve) => {
      const updateProcess = spawn('pip', ['install', `${packageName}==${version}`], {
        cwd: workingDir,
        stdio: 'pipe'
      });
      
      updateProcess.on('close', (code) => {
        resolve(code === 0);
      });
      
      updateProcess.on('error', () => {
        resolve(false);
      });
    });
  }
  
  /**
   * Find package files in project
   */
  async findPackageFiles() {
    const patterns = Object.keys(this.packageManagers).map(file => `**/${file}`);
    const files = [];
    
    for (const pattern of patterns) {
      const matches = await glob(pattern, {
        ignore: ['**/node_modules/**', '**/target/**', '**/dist/**', '**/build/**']
      });
      files.push(...matches);
    }
    
    return files;
  }
  
  /**
   * Get dependency list from package file
   */
  async getDependencyList(packageFile, packageManager) {
    const dependencies = [];
    
    try {
      switch (packageManager) {
        case 'npm':
        case 'yarn':
          const packageJson = await fs.readJson(packageFile);
          const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
          
          Object.entries(deps).forEach(([name, version]) => {
            dependencies.push({
              name,
              version: version.replace(/[^\d\.]/g, ''), // Remove version prefixes
              type: 'javascript'
            });
          });
          break;
          
        case 'pip':
          const requirements = await fs.readFile(packageFile, 'utf8');
          const lines = requirements.split('\n').filter(line => line.trim() && !line.startsWith('#'));
          
          lines.forEach(line => {
            const match = line.match(/^([^=<>!]+)[=<>!]+(.*)/);  
            if (match) {
              dependencies.push({
                name: match[1].trim(),
                version: match[2].trim(),
                type: 'python'
              });
            }
          });
          break;
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Failed to parse ${packageFile}: ${error.message}`));
    }
    
    return dependencies;
  }
  
  /**
   * Parse npm audit results
   */
  parseNpmAuditResults(auditResult) {
    const vulnerabilities = [];
    
    if (auditResult.vulnerabilities) {
      Object.entries(auditResult.vulnerabilities).forEach(([packageName, vulnData]) => {
        vulnData.via.forEach(via => {
          if (typeof via === 'object') {
            vulnerabilities.push({
              id: via.source,
              package: packageName,
              currentVersion: vulnData.range,
              severity: via.severity,
              title: via.title,
              description: via.title,
              source: 'npm-audit'
            });
          }
        });
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Parse Snyk results
   */
  parseSnykResults(snykResult) {
    const vulnerabilities = [];
    
    if (snykResult.vulnerabilities) {
      snykResult.vulnerabilities.forEach(vuln => {
        vulnerabilities.push({
          id: vuln.id,
          package: vuln.packageName,
          currentVersion: vuln.version,
          fixedVersion: vuln.fixedIn?.[0],
          severity: vuln.severity,
          title: vuln.title,
          description: vuln.description,
          references: vuln.references,
          source: 'snyk'
        });
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Parse Safety results
   */
  parseSafetyResults(safetyResult) {
    const vulnerabilities = [];
    
    if (Array.isArray(safetyResult)) {
      safetyResult.forEach(vuln => {
        vulnerabilities.push({
          id: vuln.id,
          package: vuln.package_name,
          currentVersion: vuln.installed_version,
          vulnerableVersions: vuln.vulnerable_spec,
          severity: 'medium', // Safety doesn't provide severity
          title: 'Security Vulnerability',
          description: vuln.advisory,
          source: 'safety'
        });
      });
    }
    
    return vulnerabilities;
  }
  
  /**
   * Calculate vulnerability summary
   */
  calculateVulnerabilitySummary(vulnerabilities) {
    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };
    
    vulnerabilities.forEach(vuln => {
      const severity = vuln.severity?.toLowerCase() || 'low';
      if (summary[severity] !== undefined) {
        summary[severity]++;
      }
    });
    
    return summary;
  }
  
  /**
   * Deduplicate vulnerabilities
   */
  deduplicateVulnerabilities(vulnerabilities) {
    const seen = new Set();
    return vulnerabilities.filter(vuln => {
      const key = `${vuln.package}-${vuln.id}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }
  
  /**
   * Group vulnerabilities by package file
   */
  groupVulnerabilitiesByFile(vulnerabilities) {
    const grouped = {};
    
    vulnerabilities.forEach(vuln => {
      // Try to determine which package file this vulnerability came from
      // This is simplified - in practice, you'd track this during scanning
      const packageFile = this.guessPackageFile(vuln.package);
      
      if (!grouped[packageFile]) {
        grouped[packageFile] = [];
      }
      
      grouped[packageFile].push(vuln);
    });
    
    return grouped;
  }
  
  /**
   * Guess package file for a package (simplified)
   */
  guessPackageFile(packageName) {
    // This is a simplified implementation
    // In practice, you'd track the source file during scanning
    return './package.json'; // Default to npm
  }
  
  /**
   * Check if tool is available
   */
  async checkToolAvailability(tool) {
    return new Promise((resolve) => {
      const process = spawn(tool, ['--version'], { stdio: 'pipe' });
      
      process.on('close', (code) => {
        resolve(code === 0);
      });
      
      process.on('error', () => {
        resolve(false);
      });
    });
  }
  
  /**
   * Scan container vulnerabilities (mock implementation)
   */
  async scanContainerVulnerabilities(scanResults) {
    // Mock implementation - in practice, use tools like Trivy, Snyk, or Clair
    console.log(chalk.blue('üì¶ Container vulnerability scanning not fully implemented'));
    
    // Add mock container vulnerability
    scanResults.vulnerabilities.push({
      id: 'CONTAINER-001',
      package: 'base-image',
      currentVersion: 'latest',
      severity: 'medium',
      title: 'Outdated base image',
      description: 'Container uses outdated base image with known vulnerabilities',
      source: 'container-scan'
    });
  }
  
  /**
   * Scan code vulnerabilities (mock implementation)
   */
  async scanCodeVulnerabilities(scanResults) {
    // Mock implementation - in practice, use SAST tools
    console.log(chalk.blue('üìù Code vulnerability scanning delegated to security scanner'));
    
    // This would typically delegate to the SecurityScanner
  }
}