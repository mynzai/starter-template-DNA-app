/**
 * @fileoverview Automated Git Commit System
 * Integrates with progress tracking to automatically commit changes during development
 */

import fs from 'fs-extra';
import path from 'path';
import { execSync } from 'child_process';
import chalk from 'chalk';
import { enhancedLogger as logger, ICONS } from '../utils/enhanced-logger';
import { gitValidation } from './git-validation';

export interface GitCommitOptions {
  type: 'feature' | 'bugfix' | 'refactor' | 'docs' | 'test' | 'style' | 'chore';
  scope?: string;
  description: string;
  epic?: string;
  story?: string;
  filesModified: number;
  testsAdded?: number;
  coverage?: number;
  breakingChange?: boolean;
  autoGenerated?: boolean;
}

export interface GitAutomationConfig {
  enabled: boolean;
  autoCommitOnProgress: boolean;
  autoCommitOnQualityGates: boolean;
  requireTests: boolean;
  requireQualityGates: boolean;
  branchPrefix: string;
  conventionalCommits: boolean;
  signCommits: boolean;
  pushToRemote: boolean;
}

const DEFAULT_CONFIG: GitAutomationConfig = {
  enabled: true,
  autoCommitOnProgress: true,
  autoCommitOnQualityGates: true,
  requireTests: false,
  requireQualityGates: false,
  branchPrefix: 'feature/',
  conventionalCommits: true,
  signCommits: false,
  pushToRemote: false
};

const CONFIG_FILE = path.join(process.cwd(), '.dna-git-config.json');

export class GitAutomation {
  private config: GitAutomationConfig;

  constructor() {
    this.config = this.loadConfig();
  }

  private loadConfig(): GitAutomationConfig {
    try {
      if (fs.existsSync(CONFIG_FILE)) {
        const fileConfig = fs.readJsonSync(CONFIG_FILE);
        return { ...DEFAULT_CONFIG, ...fileConfig };
      }
      return DEFAULT_CONFIG;
    } catch (error) {
      logger.warning('Failed to load Git automation config, using defaults');
      return DEFAULT_CONFIG;
    }
  }

  async saveConfig(config: Partial<GitAutomationConfig>): Promise<void> {
    try {
      this.config = { ...this.config, ...config };
      await fs.writeJson(CONFIG_FILE, this.config, { spaces: 2 });
      logger.success('Git automation config saved');
    } catch (error) {
      logger.error(`Failed to save config: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async autoCommit(options: GitCommitOptions): Promise<boolean> {
    if (!this.config.enabled) {
      logger.debug('Git automation disabled');
      return false;
    }

    try {
      // Check if there are changes to commit
      const hasChanges = this.hasUncommittedChanges();
      if (!hasChanges) {
        logger.debug('No changes to commit');
        return false;
      }

      // Create rollback point
      const rollbackId = await gitValidation.createRollbackPoint();

      // Validate requirements
      if (this.config.requireTests && !options.testsAdded) {
        logger.warning('Skipping auto-commit: Tests required but none added');
        return false;
      }

      if (this.config.requireQualityGates && (!options.coverage || options.coverage < 80)) {
        logger.warning('Skipping auto-commit: Quality gates not met');
        return false;
      }

      // Generate commit message
      const commitMessage = this.generateCommitMessage(options);

      // Validate commit message
      const messageValidation = gitValidation.validateCommitMessage(commitMessage);
      if (!messageValidation.passed) {
        logger.warning('Commit message validation failed:');
        messageValidation.errors.forEach(error => logger.warning(`  â€¢ ${error}`));
        return false;
      }

      // Stage all changes
      execSync('git add .', { stdio: 'inherit' });

      // Pre-commit validation
      const preCommitValidation = await gitValidation.validatePreCommit();
      if (!preCommitValidation.canProceed) {
        logger.warning('Pre-commit validation failed:');
        preCommitValidation.errors.forEach(error => logger.warning(`  â€¢ ${error}`));
        
        // Rollback if validation fails
        await gitValidation.rollback(rollbackId);
        return false;
      }

      // Show warnings but continue
      if (preCommitValidation.warnings.length > 0) {
        logger.warning('Pre-commit warnings:');
        preCommitValidation.warnings.forEach(warning => logger.warning(`  â€¢ ${warning}`));
      }

      // Create commit
      const commitCommand = this.config.signCommits ? 
        `git commit -S -m "${commitMessage}"` : 
        `git commit -m "${commitMessage}"`;

      execSync(commitCommand, { stdio: 'inherit' });

      logger.success(`${ICONS.git} Auto-committed: ${commitMessage.split('\n')[0]}`);

      // Push to remote if configured
      if (this.config.pushToRemote) {
        try {
          const currentBranch = this.getCurrentBranch();
          execSync(`git push origin ${currentBranch}`, { stdio: 'inherit' });
          logger.success(`${ICONS.upload} Pushed to remote: ${currentBranch}`);
        } catch (error) {
          logger.warning('Failed to push to remote (continuing anyway)');
        }
      }

      return true;

    } catch (error) {
      logger.error(`Auto-commit failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      return false;
    }
  }

  async createFeatureBranch(epic: string, story: string): Promise<string> {
    try {
      const branchName = `${this.config.branchPrefix}${epic}-${story}`;
      const sanitizedBranchName = branchName.toLowerCase().replace(/[^a-z0-9-]/g, '-');

      // Check if branch exists
      try {
        execSync(`git rev-parse --verify ${sanitizedBranchName}`, { stdio: 'pipe' });
        logger.info(`Branch ${sanitizedBranchName} already exists, checking out`);
        execSync(`git checkout ${sanitizedBranchName}`, { stdio: 'inherit' });
      } catch {
        // Branch doesn't exist, create it
        execSync(`git checkout -b ${sanitizedBranchName}`, { stdio: 'inherit' });
        logger.success(`${ICONS.branch} Created feature branch: ${sanitizedBranchName}`);
      }

      return sanitizedBranchName;

    } catch (error) {
      logger.error(`Failed to create feature branch: ${error instanceof Error ? error.message : 'Unknown error'}`);
      throw error;
    }
  }

  async commitProgressUpdate(sessionData: any): Promise<boolean> {
    if (!this.config.autoCommitOnProgress) {
      return false;
    }

    const options: GitCommitOptions = {
      type: 'chore',
      scope: sessionData.epic || 'progress',
      description: 'Update development progress tracking',
      epic: sessionData.epic,
      story: sessionData.story,
      filesModified: sessionData.progress?.filesModified || 0,
      testsAdded: sessionData.progress?.testsAdded || 0,
      coverage: sessionData.metrics?.coverage || 0,
      autoGenerated: true
    };

    return await this.autoCommit(options);
  }

  async commitFeatureCompletion(sessionData: any): Promise<boolean> {
    const options: GitCommitOptions = {
      type: 'feat',
      scope: sessionData.epic || 'core',
      description: `Complete ${sessionData.story || 'feature implementation'}`,
      epic: sessionData.epic,
      story: sessionData.story,
      filesModified: sessionData.progress?.filesModified || 0,
      testsAdded: sessionData.progress?.testsAdded || 0,
      coverage: sessionData.metrics?.coverage || 0,
      autoGenerated: true
    };

    return await this.autoCommit(options);
  }

  async commitTestUpdate(sessionData: any): Promise<boolean> {
    if (!this.config.autoCommitOnQualityGates) {
      return false;
    }

    const options: GitCommitOptions = {
      type: 'test',
      scope: sessionData.epic || 'core',
      description: `Add tests and improve coverage to ${sessionData.metrics?.coverage || 0}%`,
      epic: sessionData.epic,
      story: sessionData.story,
      filesModified: sessionData.progress?.filesModified || 0,
      testsAdded: sessionData.progress?.testsAdded || 0,
      coverage: sessionData.metrics?.coverage || 0,
      autoGenerated: true
    };

    return await this.autoCommit(options);
  }

  async commitRefactoring(sessionData: any, description: string): Promise<boolean> {
    const options: GitCommitOptions = {
      type: 'refactor',
      scope: sessionData.epic || 'core',
      description: description,
      epic: sessionData.epic,
      story: sessionData.story,
      filesModified: sessionData.progress?.filesModified || 0,
      autoGenerated: true
    };

    return await this.autoCommit(options);
  }

  private generateCommitMessage(options: GitCommitOptions): string {
    let message = '';

    if (this.config.conventionalCommits) {
      // Conventional Commits format
      const scope = options.scope ? `(${options.scope})` : '';
      const breaking = options.breakingChange ? '!' : '';
      
      message = `${options.type}${scope}${breaking}: ${options.description}`;

      // Add body with details
      const bodyParts: string[] = [];
      
      if (options.epic || options.story) {
        bodyParts.push(`Epic: ${options.epic || 'N/A'}`);
        bodyParts.push(`Story: ${options.story || 'N/A'}`);
      }

      if (options.filesModified > 0) {
        bodyParts.push(`Files modified: ${options.filesModified}`);
      }

      if (options.testsAdded && options.testsAdded > 0) {
        bodyParts.push(`Tests added: ${options.testsAdded}`);
      }

      if (options.coverage !== undefined) {
        bodyParts.push(`Coverage: ${options.coverage}%`);
      }

      if (options.autoGenerated) {
        bodyParts.push('ðŸ¤– Generated with Claude Code');
        bodyParts.push('Co-Authored-By: Claude <noreply@anthropic.com>');
      }

      if (bodyParts.length > 0) {
        message += '\n\n' + bodyParts.join('\n');
      }

      if (options.breakingChange) {
        message += '\n\nBREAKING CHANGE: ' + options.description;
      }

    } else {
      // Simple format
      message = `${options.type}: ${options.description}`;
      
      if (options.autoGenerated) {
        message += '\n\nðŸ¤– Generated with Claude Code\n\nCo-Authored-By: Claude <noreply@anthropic.com>';
      }
    }

    return message;
  }

  private hasUncommittedChanges(): boolean {
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      return status.trim().length > 0;
    } catch (error) {
      logger.warning('Failed to check Git status');
      return false;
    }
  }

  private getCurrentBranch(): string {
    try {
      return execSync('git branch --show-current', { encoding: 'utf8' }).trim();
    } catch (error) {
      return 'main';
    }
  }

  async getRepoStatus(): Promise<{
    branch: string;
    hasChanges: boolean;
    ahead: number;
    behind: number;
    lastCommit: string;
  }> {
    try {
      const branch = this.getCurrentBranch();
      const hasChanges = this.hasUncommittedChanges();
      
      let ahead = 0;
      let behind = 0;
      try {
        const status = execSync(`git rev-list --count --left-right origin/${branch}...HEAD`, { encoding: 'utf8' });
        const [behindStr, aheadStr] = status.trim().split('\t');
        behind = parseInt(behindStr) || 0;
        ahead = parseInt(aheadStr) || 0;
      } catch {
        // Remote tracking not set up
      }

      const lastCommit = execSync('git log -1 --pretty=format:"%h %s"', { encoding: 'utf8' });

      return {
        branch,
        hasChanges,
        ahead,
        behind,
        lastCommit
      };
    } catch (error) {
      throw new Error(`Failed to get repo status: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  async validateRepository(): Promise<boolean> {
    try {
      // Check if we're in a Git repository
      execSync('git rev-parse --git-dir', { stdio: 'pipe' });

      // Check if we have a remote
      try {
        execSync('git remote -v', { stdio: 'pipe' });
      } catch {
        logger.warning('No Git remote configured - push to remote disabled');
        this.config.pushToRemote = false;
      }

      // Check Git configuration
      try {
        execSync('git config user.name', { stdio: 'pipe' });
        execSync('git config user.email', { stdio: 'pipe' });
      } catch {
        logger.error('Git user name/email not configured');
        return false;
      }

      return true;
    } catch (error) {
      logger.error('Not in a Git repository or Git not configured properly');
      return false;
    }
  }
}

export const gitAutomation = new GitAutomation();