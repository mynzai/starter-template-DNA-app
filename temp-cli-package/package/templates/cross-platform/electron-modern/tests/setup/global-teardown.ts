import { FullConfig } from '@playwright/test';
import { promises as fs } from 'fs';
import path from 'path';

async function globalTeardown(config: FullConfig) {
  console.log('üßπ Starting global teardown...');
  
  // Generate test summary report
  await generateTestSummary();
  
  // Archive test artifacts
  await archiveTestArtifacts();
  
  // Clean up temporary files
  await cleanupTemporaryFiles();
  
  console.log('‚úÖ Global teardown completed');
}

async function generateTestSummary(): Promise<void> {
  try {
    const testResultsDir = path.join(__dirname, '../../test-results');
    const testResultsFile = path.join(testResultsDir, 'test-results.json');
    
    // Check if test results file exists
    try {
      await fs.access(testResultsFile);
    } catch {
      console.log('‚ö†Ô∏è No test results file found, skipping summary generation');
      return;
    }
    
    // Read test results
    const testResultsContent = await fs.readFile(testResultsFile, 'utf-8');
    const testResults = JSON.parse(testResultsContent);
    
    // Generate summary
    const summary = {
      timestamp: new Date().toISOString(),
      totalTests: testResults.stats?.total || 0,
      passed: testResults.stats?.passed || 0,
      failed: testResults.stats?.failed || 0,
      skipped: testResults.stats?.skipped || 0,
      duration: testResults.stats?.duration || 0,
      platform: process.platform,
      nodeVersion: process.version,
      electronVersion: getElectronVersion(),
      projects: testResults.suites?.map((suite: any) => ({
        name: suite.title,
        tests: suite.tests?.length || 0,
        passed: suite.tests?.filter((test: any) => test.status === 'passed').length || 0,
        failed: suite.tests?.filter((test: any) => test.status === 'failed').length || 0
      })) || []
    };
    
    // Write summary
    const summaryFile = path.join(testResultsDir, 'test-summary.json');
    await fs.writeFile(summaryFile, JSON.stringify(summary, null, 2));
    
    // Write markdown summary
    const markdownSummary = generateMarkdownSummary(summary);
    const markdownFile = path.join(testResultsDir, 'test-summary.md');
    await fs.writeFile(markdownFile, markdownSummary);
    
    console.log('üìä Test summary generated');
    
    // Log summary to console
    console.log(`\nüìà Test Summary:`);
    console.log(`  Total Tests: ${summary.totalTests}`);
    console.log(`  Passed: ${summary.passed} ‚úÖ`);
    console.log(`  Failed: ${summary.failed} ‚ùå`);
    console.log(`  Skipped: ${summary.skipped} ‚è≠Ô∏è`);
    console.log(`  Duration: ${Math.round(summary.duration / 1000)}s`);
    
  } catch (error) {
    console.error('‚ùå Failed to generate test summary:', error);
  }
}

function generateMarkdownSummary(summary: any): string {
  const passRate = summary.totalTests > 0 
    ? Math.round((summary.passed / summary.totalTests) * 100) 
    : 0;
  
  return `# Test Summary Report

## Overview
- **Timestamp**: ${summary.timestamp}
- **Platform**: ${summary.platform}
- **Node Version**: ${summary.nodeVersion}
- **Electron Version**: ${summary.electronVersion}

## Results
- **Total Tests**: ${summary.totalTests}
- **Passed**: ${summary.passed} ‚úÖ
- **Failed**: ${summary.failed} ‚ùå
- **Skipped**: ${summary.skipped} ‚è≠Ô∏è
- **Pass Rate**: ${passRate}%
- **Duration**: ${Math.round(summary.duration / 1000)}s

## Projects
${summary.projects.map((project: any) => `
### ${project.name}
- Tests: ${project.tests}
- Passed: ${project.passed}
- Failed: ${project.failed}
`).join('')}

---
*Generated by Playwright Electron Test Suite*
`;
}

async function archiveTestArtifacts(): Promise<void> {
  try {
    const testResultsDir = path.join(__dirname, '../../test-results');
    const archiveDir = path.join(__dirname, '../../test-archives');
    
    // Create archive directory
    await fs.mkdir(archiveDir, { recursive: true });
    
    // Create timestamp-based archive folder
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const archiveFolder = path.join(archiveDir, `test-results-${timestamp}`);
    
    // Copy test results to archive
    try {
      await fs.cp(testResultsDir, archiveFolder, { recursive: true });
      console.log(`üì¶ Test artifacts archived to: ${archiveFolder}`);
    } catch (error) {
      console.warn('‚ö†Ô∏è Could not archive test artifacts:', error.message);
    }
    
    // Clean up old archives (keep last 10)
    await cleanupOldArchives(archiveDir);
    
  } catch (error) {
    console.error('‚ùå Failed to archive test artifacts:', error);
  }
}

async function cleanupOldArchives(archiveDir: string): Promise<void> {
  try {
    const archives = await fs.readdir(archiveDir);
    const archiveFolders = archives
      .filter(name => name.startsWith('test-results-'))
      .sort()
      .reverse(); // Newest first
    
    // Keep only the latest 10 archives
    const archivesToDelete = archiveFolders.slice(10);
    
    for (const archive of archivesToDelete) {
      const archivePath = path.join(archiveDir, archive);
      await fs.rm(archivePath, { recursive: true, force: true });
    }
    
    if (archivesToDelete.length > 0) {
      console.log(`üóëÔ∏è Cleaned up ${archivesToDelete.length} old test archives`);
    }
    
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not clean up old archives:', error.message);
  }
}

async function cleanupTemporaryFiles(): Promise<void> {
  try {
    const tempDirs = [
      path.join(__dirname, '../../.tmp'),
      path.join(__dirname, '../../temp'),
      path.join(__dirname, '../../tmp')
    ];
    
    for (const tempDir of tempDirs) {
      try {
        await fs.rm(tempDir, { recursive: true, force: true });
      } catch {
        // Ignore errors for non-existent directories
      }
    }
    
    console.log('üßπ Temporary files cleaned up');
    
  } catch (error) {
    console.warn('‚ö†Ô∏è Could not clean up temporary files:', error.message);
  }
}

function getElectronVersion(): string {
  try {
    const packageJsonPath = path.join(__dirname, '../../package.json');
    const packageJson = require(packageJsonPath);
    return packageJson.devDependencies?.electron || 'unknown';
  } catch {
    return 'unknown';
  }
}

export default globalTeardown;